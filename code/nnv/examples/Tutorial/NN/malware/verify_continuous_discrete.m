%% Robustness verification of a NN (L infinity adversarial attack)
%  if f(x) = y, then forall x' in X s.t. ||x - x'||_{\infty} <= eps,
%  then f(x') = y = f(x)

% Load network 
mnist_model = load('mnist_model.mat');

% Load feature analysis data
feature_info = readtable('data/bodmas-feature-analysis-NEW.csv');

% Load data
data = load('data/bodmas.mat');

% Let's start with a few images per class
X = data.X;
y = data.y;
y = y'; % transpose
y = y+1; % matlab predictions are 1 or 2 

% Scale the data-- > must be scaled! (same scaling as used for training)
X_scaled = zscore(X); % standard scaler equivalent

% Init variables
rng(0); % initialize random seed to select inputs to verfy
N = 5; % number of samples to verify (may be different for every model)
idxs = randperm(size(X_scaled,1),N);
XData = X_scaled(idxs,:);
YData = y(idxs);

% Load model (choose any of these)
models = ["models/malware_bodmas_binary_scaled_none-2.onnx";
    "models/malware_bodmas_binary_scaled_4-2.onnx";
    "models/malware_bodmas_binary_scaled_16-2.onnx"];

% Verify every model (we'll just choose one for this tutorial)
modelNumber = 1; % 1, 2, or 3

% Steps to verification approach
% 1) Counterexample search
% 2) Iterative approach for reachability (fast/overapprox -> slow/exact)

    
% Select model
modelName = models(modelNumber);

% Name fix
saveName = split(modelName,'/');
saveName = split(saveName{end}, '.');
saveName = saveName{1};
disp("Running model: "+saveName);

% load model and convert
netonnx = importONNXNetwork(modelName, "InputDataFormats", "BC");
net = matlab2nnv(netonnx); % convert to NNV
numClasses = 2;
net.OutputSize = numClasses;

% Robustness verification

% Define reachability options
reachOptions.reachMethod = 'relax-star-area';
reachOptions.relaxFactor = 0.5;
epsilon = [0.01; 0.05; 0.1]; % scale of attack 
nE = length(epsilon); % number of different attacks to evaluate
res = zeros(N,nE); % robust result
time = zeros(N,nE); % computation time
met = repmat("relax", [N, nE]); % method used to compute result
nR = 497; % number of random samples from input set to eval (for falsification)
for e=1:nE
    
    ep = epsilon(e);

    for i=1:N
        % fewer prints for bigger runs
        if N > 20
            if mod(i, 20) == 0
                disp("Verifying example:  "+string(i));
            end
        else
            disp("Verifying example:  "+string(i));
        end

        % Create input set
        IS = L_inf_attack_informed(XData(i,:), ep, feature_info);
        
        % Let's try some simple "refinement" (sim, relax, approx)
        t = tic;
        
        % Attempt at falsification
        xBox = Box(IS.im_lb', IS.im_ub');
        xF = xBox.sample(nR); % create random samples

        % Add bounds and original input 
        xF(:,nR+1) = XData(i,:); % add original image
        xF(:,nR+2) = IS.im_lb'; % add lower bound
        xF(:,nR+3) = IS.im_ub'; % add upper bound

        % Classify all random inputs and look for counterexamples
        predictedLabels = classify(netkeras, xF');
        predictedLabels = cellfun(@(x) str2double(x), cellstr(predictedLabels));

        % print to screen
        disp("Time spent after simulation: " + string(toc(t))+" seconds");

        % Any misclassified?
        if any(predictedLabels ~= YData(i))
            
            temp = 0; % counterexample found
            met(i,e) = "counterexample";

        else % attempt to verify using reachability analysis

            temp = net.verify_robustness(IS,reachOptions,YData(i));
            disp("Time spent after reachability: " + string(toc(t))+" seconds");

        end
        res(i,e) = temp;
        time(i, e) = toc(t);
        disp("Total time spent: " + string(toc(t))+" seconds");
        disp(" ");

    end
    
    % Print Results
    disp("========  RESULTS  e: "+string(epsilon(e))+" ========");
    disp("");
    disp("Average computation time: "+string(sum(time(:,e))/N));
    disp("Robust = "+string(sum(res(:,e)==1))+" out of " + string(N) + " images");
    disp(" ");

end


%% Let's visualize the ranges for every possible output (for one sample)

% Get output reachable set
R = net.reachSet{end};

% Get (overapproximate) ranges for each output index
[lb_out, ub_out] = R.getRanges;
lb_out = squeeze(lb_out);
ub_out = squeeze(ub_out);

% Get middle point for each output and range sizes
mid_range = (lb_out + ub_out)/2;
range_size = ub_out - mid_range;

% Label for x-axis
x = [0 1 2 3 4 5 6 7 8 9];

% Visualize set ranges and evaluation points
figure;
errorbar(x, mid_range, range_size, '.');
hold on;
xlim([-0.5 9.5]);
scatter(x,Y_outputs, 'x', 'MarkerEdgeColor', 'r');



%% Helper Functions


function IS = L_inf_attack_informed(x,epsilon,info)
    % This uses epsilon to scale the range between a features scaled values.
    % Just looking at continuous features right now
    % Categories include: ['Continuous', 'Hash Categorical' ,
    %           'Hash Categorical Discrete', 'Discrete with large range' ,
    %           'Binary', 'Categorical' ,'Mem related']

    mask = strcmp(info.Category, ["Continuous", "Discrete with large range"]);
    indices = find(mask);
    
    % get range for each feature
    range = info.scaled_max - info.scaled_min;
    diff = zeros(size(range));
    
    % only use the selected variables
    diff(indices) = range(indices);
    
    % apply epsilong to every value
    diff = diff * epsilon;
    
    % permute dimensions
    diff = diff';

    % --> lb = x - diff (diff is epsilon informed by info)
    lb = x - diff;
    lb = max(lb, info.scaled_min.'); % ensure no values < min value

    % --> ub = x + diff (diff is epsilon informed by info)
    ub = x + diff;
    ub = min(ub, info.scaled_max.'); % ensure no values > max value 

    % Create input set based on bounds
    IS = ImageStar(lb,ub);
    
end
